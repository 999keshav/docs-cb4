<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="concept_rnt_zfk_np">
 <title>FROM clause</title>

 <conbody>
  <p>The <codeph>FROM</codeph> clause of a <codeph>SELECT</codeph> query or subquery defines the
            keyspaces and the source of input documents or objects for the query. Every
                <codeph>FROM</codeph> clause specifies one or more keyspaces. The first keyspace is
            called the primary keyspace, and it is an optional clause for your query. </p>
        <p>If the <codeph>FROM</codeph> clause is omitted, the input for the query is a single empty
            object that allows you to perform calculations with the <codeph>SELECT</codeph>
            statement.</p>
        <p><b>Syntax</b><codeblock>FROM <varname>from-keyspace</varname> [ [ AS ] <varname>alias1</varname> ] [ USE KEYS <varname>use-clause</varname> ]  
                    | "(" SELECT ")" [ [ AS ] <varname>alias2</varname> ]
                    | <varname>expr</varname> [ [ AS ] <varname>alias3</varname> ]
                    | <varname>from-term</varname> ( <varname>join-clause</varname> | <varname>nest-clause</varname> | <varname>unnest-clause</varname> )  </codeblock></p>
     <p>
            <image placement="break" href="images/from-term.png" id="image_uy5_kzt_pz"/>
        </p>
        <note>Couchbase Server version 4.x supports only keyspace identifier or a subquery in the
                <codeph>from-term</codeph>, but not expressions. Couchbase Server version 4.6.2 adds
            support for generic <xref href="#concept_rnt_zfk_np/section_fkc_ftt_nz" format="dita"
                >expression</xref> in the <codeph>from-term</codeph>.</note>
        <dl>
            <dlentry>
                <dt>Arguments</dt>
                <dd>
                    <dl>
                        <dlentry>
                            <dt>from-keyspace</dt>
                            <dd>[Optional] String or <xref
                                    href="#concept_rnt_zfk_np/section_fkc_ftt_nz" format="dita"
                                    >expression</xref> resulting in a string that represents the
                                keyspace or source of input documents. For details, see <xref
                                    href="#concept_rnt_zfk_np/keyspaces" format="dita"
                                    >Keyspaces</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt><codeph>AS</codeph> alias</dt>
                            <dd>[Optional] To assign another name. For details, see <xref
                                    href="#concept_rnt_zfk_np/as" format="dita">AS
                                Keyword</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt><codeph>USE KEYS</codeph></dt>
                            <dd>[Optional] To specify one or multiple primary keys.  For details,
                                see <xref href="#concept_rnt_zfk_np/use-keys-clause" format="dita"
                                    >USE KEYS Clause</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt><codeph>SELECT</codeph></dt>
                            <dd>[Optional] To create a subquery of input objects. For details, see
                                    <xref href="selectclause.dita#topic_SELECT_Clause">SELECT
                                    Clause</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>expr</dt>
                            <dd>[Optional] A string expression of input objects.  For details, see
                                    <xref href="index.dita#n1ql-lang-ref">N1QL
                                Expressions</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>from-term</dt>
                            <dd>[Optional] The <varname>from-term</varname> defines the input
                                objects for the query and it can be either a keyspace identifier or
                                an expression.</dd>
                            <dd>When using nested subqueries, the <varname>from-term</varname> of
                                the outermost parent query can only have a <xref
                                    href="#concept_rnt_zfk_np/section_ekc_ftt_nz" format="dita"
                                    >keyspace identifier</xref>, a subquery, or a <xref
                                    href="#concept_rnt_zfk_np/section_fkc_ftt_nz" format="dita"
                                    >constant expression</xref> since the
                                    <varname>from-term</varname> needs to independently produce
                                input documents for the query.</dd>
                            <dd>However, the subqueries can use generic variable expressions, which
                                may be dependent on the <xref
                                    href="subqueries.dita#topic_9/section_onz_3tj_mz"/>. For
                                details, see <xref href="subqueries.dita#topic_9"/>. </dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>join-clause</dt>
                            <dd>[Optional] To create new input objects by combining two or more
                                source objects either via a <xref
                                    href="#concept_rnt_zfk_np/lookup-join" format="dita">Lookup
                                    JOIN</xref> or an <xref href="#concept_rnt_zfk_np/index-join"
                                    format="dita">Index JOIN</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>nest-clause</dt>
                            <dd>[Optional] To produce a single result of joining two keyspaces. For
                                details, see <xref href="#concept_rnt_zfk_np/nest" format="dita"
                                    >NEST Clause</xref>.</dd>
                        </dlentry>
                    </dl>
                    <dl>
                        <dlentry>
                            <dt>unnest-clause</dt>
                            <dd>[Optional] To perform a join of the nested array with its parent.
                                For details, see <xref href="#concept_rnt_zfk_np/unnest"
                                    format="dita">UNNEST Clause</xref>.</dd>
                        </dlentry>
                    </dl>
                </dd>
            </dlentry>
        </dl>
  
  <p/>
        <p/>
        <section id="section_yp1_dpf_bcb">
            <title>Omitted FROM Clause</title>
            <p>If the <codeph>FROM</codeph> clause is omitted, the data source is equivalent to an
                array containing a single empty object. This allows you to evaluate expressions that
                do not depend on stored data.</p>
            <p><b>Omitted <codeph>FROM</codeph> Example 1: Evaluating an expression.</b></p>
            <p>Add the two numbers 10 and 20 together.<codeblock>SELECT 10 + 20</codeblock> This
                results in:</p>
            <codeblock>[
  {
    "$1" : 30
  }
] </codeblock>
            <p><b>Omitted <codeph>FROM</codeph> Example 2: Selecting the local time.</b></p>
            <p>Select the local time and format the result as
                "yyyy-mm-dd".<codeblock>SELECT NOW_LOCAL('1111-11-11')</codeblock></p>
            <p>This results in:</p>
            <codeblock>[
  {
    "$1": "2017-11-30"
  }
]</codeblock>
            <p><b>Omitted <codeph>FROM</codeph> Example 3: Calculating the days until
                Christmas.</b></p>
            <p>Use the DATE_DATE_STR function to calculate the days from now until
                Christmas.<codeblock>SELECT DATE_DIFF_STR('2017-12-25',NOW_LOCAL('1111-11-11'),'day')</codeblock>This
                results in:</p>
            <codeblock>[
  {
    "$1": 25
  }
]</codeblock>
        </section>
        <section id="keyspaces">
            <title>Keyspaces</title>
            <p>The simplest type of <codeph>FROM</codeph> clause specifies a keyspace:</p>
            <codeblock>SELECT * FROM `travel-sample`;</codeblock>
            <p>This returns every value in the <codeph>`travel-sample`</codeph> keyspace.</p>
            <p>The keyspace can be prefixed with an optional namespace (pool):</p>
            <codeblock>SELECT * FROM <?oxy_custom_start type="oxy_content_highlight" color="255,255,0"?>main<?oxy_custom_end?>:`travel-sample`;</codeblock>
            <p>This queries the customer keyspace in the main namespace.</p>
            <p>If the namespace is omitted, the default namespace in the current session is
                used.</p>
        </section>
        <section id="section_ekc_ftt_nz"><title>Keyspace Identifier</title><p>This is the name or
                identifier of an independent keyspace that can serve as a data source or keyspace of
                one or more documents. Such keyspaces are not dependent on any of the <xref
                    href="subqueries.dita#topic_9/section_onz_3tj_mz"/>.</p><b>Keyspace Example 1:
                Use the <codeph>`travel-sample`</codeph> keyspace.</b><p>Select 4 unique landmarks
                from the keyspace
                <codeph>`travel-sample`</codeph>.</p><p><codeblock>SELECT t1.city
FROM `travel-sample` t1
WHERE t1.type = "landmark" LIMIT 4;</codeblock>This
                results
                in:<codeblock>[
  {
    "city": "Gillingham"
  },
  {
    "city": "Giverny"
  },
  {
    "city": "Glasgow"
  },
  {
    "city": "Clarkston"
  }
]</codeblock></p><p><b>Keyspace
                    Example 2: Cities that have landmarks and airports. (non-correlated)</b></p><p
                dir="ltr">The following non-correlated subquery uses the keyspace
                    <codeph>`travel-sample`</codeph> independent of the same keyspace used in the
                outer query:
                </p><p><codeblock>SELECT DISTINCT t1.city
FROM `travel-sample` t1
WHERE t1.type = "landmark"  
AND   t1.city IN (SELECT RAW city
                  FROM `travel-sample` 
                  WHERE type = "airport")
LIMIT 3;</codeblock>This
                results
                in:<codeblock>[
  {
    "city": "Avignon"
  },
  {
    "city": "Bangor"
  },
  {
    "city": "Glasgow"
  }
]</codeblock></p><p
                dir="ltr"><b>Keyspace Example 3: Cities that have museum landmarks.
                (correlated)</b></p><p dir="ltr">The following correlated subquery uses the keyspace
                alias from an outer
                query:</p><p><codeblock>SELECT t1.city, t1.name
FROM `travel-sample` t1
WHERE t1.type = "landmark"  
AND   (SELECT RAW t2
       FROM SPLIT(t1.name) t2 
       WHERE t2 = "museum")[0] IS NOT NULL
LIMIT 3;</codeblock>This
                results
                in:<codeblock>[
  {
    "city": "Washington",
    "name": "Washington 'F' Pit mining museum"
  },
  {
    "city": "L'Isle-sur-la-Sorgue",
    "name": "Campredon museum"
  },
  {
    "city": "Isle of Anglesey",
    "name": "Swtan heritage museum"
  }
]</codeblock></p><p
                dir="ltr"><b>Keyspace Example 3: Cities that have landmarks and breweries.</b></p><p
                dir="ltr">The following subquery example uses different keyspaces in the outer and
                inner
                queries.</p><p><codeblock>SELECT DISTINCT t1.city
FROM `travel-sample` t1
WHERE t1.type = "landmark" 
AND   t1.city IN (SELECT RAW b1.city
                  FROM `beer-sample` b1
                  WHERE b1.type = "brewery")
LIMIT 3;</codeblock>This
                results
                in:<codeblock>[
  {
    "city": "Bangor"
  },
  {
    "city": "East Lothian"
  },
  {
    "city": "Escondido"
  }
]</codeblock></p></section>
        <section id="section_fkc_ftt_nz">
            <title>N1QL Expression</title>
            <p>Couchbase Server version 4.6.2 adds support for generic <xref
                    href="index.dita#n1ql-lang-ref">expressions</xref> in the
                    <codeph>from-term</codeph>. This is a very powerful functionality as it enables
                usage of various N1QL functions, operators, path expressions, language constructs on
                constant expressions, variables, and subqueries. <ul id="ul_jwy_fyx_mz">
                    <li dir="ltr">
                        <p dir="ltr">When the <codeph>from-term</codeph> is an expression,
                                <codeph>USE KEYS</codeph> or <codeph>USE INDEX</codeph> clauses are
                            not allowed.</p>
                    </li>
                    <li dir="ltr">
                        <p dir="ltr">When using a <codeph>JOIN</codeph> clause,
                                <codeph>NEST</codeph> clause, or <codeph>UNNEST</codeph> clause, the
                            left-side keyspace can be an expression or subquery, but the right-side
                            keyspace must be a keyspace identifier.</p>
                        <dl>
                            <dlentry>
                                <dt><b>Independent Constant Expression</b></dt>
                                <dd/>
                                <dd>This includes any N1QL expressions of JSON scalar values, static
                                    JSON literals, objects, or N1QL functions. For example:<p>
                                        <codeblock>SELECT * FROM [1, 2, "name", { "type" : "airport", "id" : "SFO"}]  AS  ks1;

SELECT * FROM CURL(...) as ks2;</codeblock>
                                    </p><p dir="ltr">Note that functions such as <xref
                                            href="curl.dita#topic_8_8">CURL()</xref> can
                                        independently produce input data objects for the query.
                                        However, other N1QL functions can also be used in the
                                        expressions.</p></dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>Variable N1QL Expression</b></dt>
                                <dd/>
                                <dd>This includes expressions that refers to any <xref
                                        href="subqueries.dita#topic_9/section_onz_3tj_mz">variables
                                        in scope</xref> for the query. This is applicable to only
                                    subqueries because the outermost level query cannot use any
                                    variables in its own <codeph>FROM</codeph> clause. This makes
                                    the subquery correlated with outer queries, as explained in the
                                        <xref href="subqueries.dita#topic_9"/> section. </dd>
                            </dlentry>
                        </dl>
                        <dl>
                            <dlentry>
                                <dt><b>Subquery and Subquery Expressions</b></dt>
                                <dd/>
                                <dd>A subquery itself can appear as a <codeph>from-term</codeph>
                                    expression. In this case, the subquery results are fed as data
                                    source to the outer query. Further, subqueries can occur as a
                                    subquery or as constituent part of a bigger N1QL expression.<p
                                        dir="ltr"><b>Subquery Example 1a: Highest altitude
                                            airport/city in each country. (with a
                                        subquery)</b></p><p dir="ltr">The following shows a simple
                                        case of using a subquery in the <codeph>FROM</codeph>
                                        clause:</p><p><codeblock>SELECT t1.country, t1.max_country_alt, 
       ARRAY x.city FOR x IN t1.c 
       WHEN x.alt = t1.max_country_alt END
FROM (SELECT  country, array_agg({"alt": geo.alt , city}) c,
   max_country_alt
      FROM `travel-sample` 
      WHERE type = "airport"
      GROUP BY country 
LETTING max_country_alt = max(geo.alt) ) t1;</codeblock>(in
                                        107ms) This results
                                            in:<codeblock>[
  {
    "$1": [
      "Shaftesbury"
    ],
    "country": "United Kingdom",
    "max_country_alt": 811
  },
  {
    "$1": [
      "Courcheval"
    ],
    "country": "France",
    "max_country_alt": 6588
  },
  {
    "$1": [
      "Telluride"
    ],
    "country": "United States",
    "max_country_alt": 9078
  }
]</codeblock><b>Subquery
                                            Example 1b: Highest altitude airports/cities in each
                                            country. (without a subquery)</b></p><p>The same query
                                        as above, but use N1QL's power to express it without a
                                        subquery.<codeblock>SELECT  country, 
        (ARRAY x.city FOR x IN array_agg({"alt": geo.alt, city}) 
        WHEN x.alt = max_country_alt END) AS max_alt_city,
        max_country_alt
FROM `travel-sample` 
WHERE type = "airport"
GROUP BY country 
LETTING max_country_alt = max(geo.alt);</codeblock>(in
                                        104ms) This results
                                        in:<codeblock>[
  {
    "country": "United Kingdom",
    "max_alt_city": [
      "Shaftesbury"
    ],
    "max_country_alt": 811
  },
  {
    "country": "France",
    "max_alt_city": [
      "Courcheval"
    ],
    "max_country_alt": 6588
  },
  {
    "country": "United States",
    "max_alt_city": [
      "Telluride"
    ],
    "max_country_alt": 9078
  }
]</codeblock></p>A
                                    more realistic example of needing subquery in the
                                        <codeph>FROM</codeph> clause arises in more complicated
                                    scenarios, such as when multiple levels of aggregates (sort
                                    orders and limits) are required, or when the subquery results of
                                    one keyspace may need to be JOINed with another keyspace. </dd>
                                <dd><b>Subquery Example 2: For each country, find the number of
                                        airports at different altitudes and their corresponding
                                        cities.</b></dd>
                                <dd>In this case, the inner query finds the first level of grouping
                                    of different altitudes by country and corresponding number of
                                    cities. Then the outer query builds on the inner query results
                                    to count the number of different altitude groups for each
                                    country and the total number of
                                        cities.<p><codeblock>SELECT t1.country, num_alts, total_cities
FROM (SELECT country, geo.alt AS alt,
             count(city) AS num_cities
      FROM `travel-sample` 
      WHERE type = "airport"
      GROUP BY country, geo.alt) t1
GROUP BY t1.country 
LETTING num_alts = count(t1.alt), total_cities = sum(t1.num_cities);</codeblock>This
                                        results
                                        in:<codeblock>[
  {
    "country": "United States",
    "num_alts": 946,
    "total_cities": 1560
  },
  {
    "country": "United Kingdom",
    "num_alts": 128,
    "total_cities": 187
  },
  {
    "country": "France",
    "num_alts": 196,
    "total_cities": 221
  }
]</codeblock></p>This
                                    is equivalent to blending the results of the following two
                                    queries by country, but the subquery in the
                                        <codeph>from-term</codeph> above simplified
                                    it.<codeblock>SELECT country,count(city) AS num_cities
FROM `travel-sample` 
WHERE type = "airport"
GROUP BY country;

SELECT country, count(distinct geo.alt) AS num_alts
FROM `travel-sample` 
WHERE type = "airport"
GROUP BY country;</codeblock>
                                    See <xref href="subqueries.dita#topic_9"/> for details and
                                    examples. </dd>
                            </dlentry>
                            <dlentry>
                                <dt><b>Nested Path Expressions</b></dt>
                                <dd/>
                                <dd>Expressions used in the <codeph>from-term</codeph> can have
                                    nested paths, including constant or variable or subquery
                                    expressions. Similarly, variable expressions are allowed in only
                                    subqueries (not in outermost parent queries). </dd>
                                <dd>Further, the nested-path variable expression in a subquery
                                        <codeph>from-term</codeph> must resolve to variables/aliases
                                    in scope, and not to any keyspace identifiers. Otherwise, it
                                    results in a syntax error.<note>When an expression cannot be
                                        resolved to any variables in scope, it is considered
                                        keyspace identifier. See <xref
                                            href="subqueries.dita#topic_9/nested-path-expr">Nested
                                            Paths in Subqueries</xref> for more details. </note><p
                                        dir="ltr"><b>Nested Example 1: Usage of a nested path over a
                                            subquery
                                        expression.</b></p><p><codeblock>SELECT x.geo.alt
FROM (SELECT geo from `travel-sample` 
      WHERE type = "airport") AS x
LIMIT 2;</codeblock>This
                                        results
                                        in:<codeblock>[
  {
    "alt": 12
  },
  {
    "alt": 295
  }
]</codeblock></p><p/><b>Nested
                                        Example 2: Usage of a nested path over a constant
                                        expression.</b><codeblock>SELECT x.b FROM 
         [{"a" : 1, "b" : {"c" : 2}},
          {"a" : 3, "b" : {"d" : 4}}] AS x
LIMIT 2;</codeblock>This
                                    results
                                    in:<codeblock>[
  {
    "x": {
      "c": 2
    }
  },
  {
    "x": {
      "d": 4
    }
  }
]</codeblock></dd>
                            </dlentry>
                        </dl>
                    </li>
                </ul></p>
        </section>
     
 
     <section><title id="use-keys-clause">USE KEYS Clause</title>
     <p>Specific primary keys within a keyspace can be specified. Only values having those primary
                keys will be included as inputs to the query.</p>
            <p><b>Syntax</b></p>
            <codeblock>USE [ PRIMARY ] KEYS <varname>key_expression</varname> </codeblock>
         <p><dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>PRIMARY</dt>
                                    <dd>[Optional] Make the <varname>key_expression</varname> a
                                        unique Primary Key.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>key_expression</dt>
                                    <dd>String of one or more fields to be used as a key.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl><b><codeph>USE KEYS</codeph> Example 1: Specify a single key.</b></p>
         <codeblock>SELECT * FROM customer USE KEYS "acme-uuid-1234-5678"</codeblock>
         <p><b><codeph>USE KEYS</codeph> Example 2: Specify multiple keys.</b></p>
         <codeblock>SELECT * FROM customer USE KEYS [ "acme-uuid-1234-5678", "roadster-uuid-4321-8765" ]</codeblock>
         <p>
                <note>In the <codeph>FROM</codeph> clause of a subquery, <codeph>USE KEYS</codeph>
                    is mandatory for the primary keyspace.</note>
            </p>
     </section>
     
     <section id="lookup-join-clause"><title>Lookup JOIN Clause</title>
            <p><i>(Introduced in Couchbase Server 4.5)</i></p>
    <p>The <codeph>JOIN</codeph> clause enables you to create new input objects by combining two or
                more source objects. </p>
            <p>Lookup joins allow only left-to-right joins, which means each qualified document from
                the left-hand side (LHS) of the <codeph>JOIN</codeph> operator is required to
                produce primary keys of documents on the right-hand side (RHS). These keys are
                subsequently nested-loop-joined to access qualified RHS documents.</p>
            <p>The <varname>joins-clause</varname> is optional, and follows the
                    <codeph>FROM</codeph> clause; it allows you to combine two or more source
                objects to use as input objects. The <codeph>KEYS</codeph> clause is required after
                each <codeph>JOIN</codeph>. It specifies the primary keys of the documents for the
                second keyspace in the join.</p>
            <p><b>Syntax</b></p>
            <codeblock>[ <varname>join-type</varname> ] JOIN <varname>from-path</varname> [ [ AS ] <varname>alias</varname> ] ON KEYS <varname>on-keys-clause</varname></codeblock>
         <p id="lookup-join">
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd>[Optional; default is <codeph>LEFT INNER</codeph>]</dd>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT</codeph> or <codeph>LEFT
                                                  INNER</codeph></dt>
                                                <dd>For each joined object produced, both the
                                                  left-hand and right-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt><codeph>LEFT OUTER</codeph></dt>
                                                <dd>For each joined object produced, only the
                                                  left-hand source objects must be
                                                  non-<codeph>MISSING</codeph> and
                                                  non-<codeph>NULL</codeph>.</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>from-path</dt>
                                    <dd>String or <xref
                                            href="#concept_rnt_zfk_np/section_fkc_ftt_nz"
                                            format="dita">expression</xref> resulting in a string
                                        that represents the keyspace or source of input documents.
                                        For details, see <xref href="#concept_rnt_zfk_np/keyspaces"
                                            format="dita">Keyspaces</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>AS</codeph> alias</dt>
                                    <dd>[Optional] To assign another name. For details, see <xref
                                            href="#concept_rnt_zfk_np/as" format="dita">AS
                                            Keyword</xref>.</dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt><codeph>ON KEYS</codeph> on-keys-clause</dt>
                                    <dd>String or expression representing the Primary Index Key
                                        field.</dd>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
                <dl>
                    <dlentry>
                        <dt>Return Values</dt>
                        <dd>If <codeph>LEFT</codeph> or <codeph>LEFT OUTER</codeph> is specified,
                            then a left outer join is performed.</dd>
                        <dd>At least one joined object is produced for each left-hand source
                            object.</dd>
                        <dd>If the right-hand source object is <codeph>NULL</codeph> or
                                <codeph>MISSING</codeph>, then the joined object's right-hand side
                            value is also <codeph>NULL</codeph> or <codeph>MISSING</codeph>
                            (omitted), respectively. </dd>
                    </dlentry>
                </dl>
            </p>
<p>
                <b>Lookup JOIN Example 1: invoice JOIN customer on customer_key.</b></p><p> If our <codeph>customer</codeph> objects were:
                <codeblock>  {
     "name": ...,
     "primary_contact": ...,
     "address": [ ... ]
     }          </codeblock></p>
 
     <p>And our <codeph>invoice</codeph> objects
                were:<codeblock>   {
      "customer_key": ...,
      "invoice_date": ...,
      "invoice_item_keys": [ ... ],
      "total": ...
      }</codeblock></p>
         
     <p>And the <codeph>FROM</codeph> clause was:
                <codeblock>FROM invoice inv JOIN customer cust ON KEYS inv.customer_key     </codeblock></p>
  
     <p>Then each joined object would
                be:<codeblock>    {
        "inv" : {
            "customer_key": ...,
            "invoice_date": ...,
            "invoice_item_keys": [ ... ],
            "total": ...
        },
        "cust" : {
            "name": ...,
            "primary_contact": ...,
            "address": [ ... ]
        }
    }      </codeblock></p>
            <p><b>Lookup JOIN Example 2: invoice JOIN invoice_item ON invoice_item_keys.</b></p>
 
     <p>If our <codeph>invoice_item</codeph> objects were:
                <codeblock>   {
        "invoice_key": ...,
        "product_key": ...,
        "unit_price": ...,
        "quantity": ...,
        "item_subtotal": ...
        }          </codeblock></p>
 
     <p>And the <codeph>FROM</codeph> clause was:
                <codeblock>FROM invoice JOIN invoice_item item ON KEYS invoice.invoice_item_keys</codeblock></p>

     <p>Then our joined objects would be:<codeblock>   {
        "invoice" : {
            "customer_key": ...,
            "invoice_date": ...,
            "invoice_item_keys": [ ... ],
            "total": ...
        },
        "item" : {
            "invoice_key": ...,
            "product_key": ...,
            "unit_price": ...,
            "quantity": ...,
            "item_subtotal": ...
        }
    },
    {
        "invoice" : {
            "customer_key": ...,
            "invoice_date": ...,
            "invoice_item_keys": [ ... ],
            "total": ...
        },
        "item" : {
            "invoice_key": ...,
            "product_key": ...,
            "unit_price": ...,
            "quantity": ...,
            "item_subtotal": ...
        }
    },
    ...</codeblock></p>

     <p>
                <note><codeph>ON KEYS</codeph> is required after each <codeph>JOIN</codeph>. It
                    specifies the primary keys for the second keyspace in the join.</note>
            </p>
     <p>Joins can be chained.</p>
            <p><b>Lookup JOIN Example 3: chained joins.</b></p>
            <p/>
   </section>      
     
 <section id="index-join-clause"><title>Index JOIN Clause</title>
            <p><b>Syntax</b></p>
            <codeblock>[ <varname>join-type</varname> ] JOIN <varname>from-path</varname> [ [ AS ] <varname>alias</varname> ] ( <varname>on-keys-clause</varname> | <varname>on-key-for-clause</varname> )</codeblock>
            <p>
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd>
                                        <dl>
                                            <dlentry>
                                                <dt>INNER</dt>
                                                <dd>Inner JOIN</dd>
                                            </dlentry>
                                        </dl>
                                        <dl>
                                            <dlentry>
                                                <dt>LEFT</dt>
                                                <dd>Left JOIN</dd>
                                                <dd>[Optional] OUTER LEFT JOIN</dd>
                                            </dlentry>
                                        </dl>
                                    </dd>
                                </dlentry>
                            </dl>
                            <dl>
                                <dlentry>
                                    <dt>from-path</dt>
                                    <dd/>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
            </p>
            <p><i>on-keys-clause:</i></p>
            <codeblock>ON [ PRIMARY ] KEYS expression  </codeblock>
            <p><varname>on-key-for-clause:</varname></p>
            <codeblock>ON [ PRIMARY ] KEY <varname>rhs-expression</varname>.<varname>lhs-expression-key</varname> FOR <varname>lhs-expression</varname> </codeblock>
            <p><varname>rhs-expression</varname>: keyspace or expression corresponding to the right
                hand side of JOIN.</p>
            <p><varname>lhs-expression</varname>: keyspace or expression corresponding to the left
                hand side of JOIN.</p>
            <p><varname>lhs-expression-key</varname>: attribute in <varname>rhs-expression</varname>
                referencing primary key for <varname>lhs-expression</varname>.</p>
 <p>When using lookup joins, right-to-left joins with RHS documents containing primary key
                references to LHS documents cannot be joined efficiently using any index. </p>
            <p>For example, consider the <b>travel-sample</b> data with route and airline documents,
                where <varname>route.airlineid</varname> is the primary key of route documents and
                airline documents have no reference to route documents. The following query to get a
                list of flights from airlines flying to SFO cannot be efficiently executed without
                making a Cartesian product of all route documents (LHS) with all airline documents
                (RHS):
                <codeblock>SELECT DISTINCT airline.name, airline.callsign, route.destinationairport, route.stops, route.airline
FROM `travel-sample` route 
  JOIN `travel-sample` airline 
  ON KEYS route.airlineid 
WHERE route.type = "route" 
  AND airline.type = "airline" 
  AND route.sourceairport = "SFO" 
LIMIT 2;</codeblock>This
                query cannot use any index on <codeph>airline</codeph> to directly access
                    <codeph>sourceairport</codeph> in SFO  because <codeph>airline</codeph> is on
                the RHS. Also, you cannot rewrite the query to put the airline document on the LHS
                (to use any index) and the <codeph>route</codeph> document on the RHS because the
                    <codeph>airline</codeph> documents (on the LHS) have no primary keys to access
                the <codeph>route</codeph> documents (on the RHS). </p>
         <p>Using the new <term>index joins</term>, the same query can be written as:
                <codeblock>Required Index:
CREATE INDEX route.airlineid ON `travel-sample`(airlineid) WHERE type="route";
                 
Optional index:
CREATE INDEX route.sourceairport ON `travel-sample`(sourceairport) WHERE type="route";

Resulting in:
SELECT * FROM `travel-sample` airline JOIN `travel-sample` route
    ON KEY route.airlineid FOR airline
    WHERE route.type="route" AND airline.type="airline" AND route.sourceairport = "SFO";                 </codeblock></p>
         <p>If you generalize the same query, it looks like the following:
                <codeblock>CREATE INDEX <varname>on-key-for-index-name</varname> <varname>rhs-expression</varname> (<varname>lhs-expression-key</varname>);
                 
SELECT <varname>projection-list</varname> FROM <varname>lhs-expression</varname> JOIN <varname>rhs-expression</varname>
    ON KEY <varname>rhs-expression</varname>.<varname>lhs-expression-key</varname> FOR <varname>lhs-expression</varname>      
   [ WHERE <varname>predicates</varname> ] ; </codeblock></p>
            <p>There are three important changes in the index scan syntax example above: <ul
                    id="ul_fky_g32_1v">
                    <li><codeph>CREATE INDEX</codeph> on the <codeph>ON KEY</codeph> expression
                            <codeph>route.airlineid</codeph> to access <codeph>route</codeph>
                        documents using <codeph>airlineid</codeph> (which are produced on the
                        LHS).</li>
                    <li>The <codeph>ON KEY route.airlineid FOR airline</codeph> enables N1QL to use
                        the index <codeph>route.airlineid</codeph>.</li>
                    <li>Create any optional index such as <codeph>route.sourceairport</codeph> that
                        can be used on route (LHS).</li>
                </ul><note>For index joins, the syntax uses <codeph>ON KEY</codeph> (singular)
                    instead of <codeph>ON KEYS</codeph> (plural). This is because for index joins,
                    the <codeph>ON KEY</codeph> expression must produce a scalar value. For lookup
                    joins, the <codeph>ON KEYS</codeph> expression can produce either a scalar or an
                    array value. </note></p>
         <p><b>Syntax of Index Joins</b></p>
         <p>A new <codeph>on-key-for-clause</codeph> is added to the <codeph>join-clause</codeph> of the
             <xref href="http://developer.couchbase.com/documentation/server/4.1/n1ql/n1ql-language-reference/from.html"
                 format="html" scope="external">FROM</xref> syntax. </p>
         <codeblock>[ <varname>join-type</varname> ] JOIN <varname>from-path</varname> [ [ AS ] alias ] &lt; <varname>on-key-for-clause</varname> &gt;</codeblock>
         <p><varname>on-keys-clause</varname>: </p>
         <codeblock>ON [ PRIMARY ] KEYS <varname>expression</varname> </codeblock>
         <p><varname>on-key-for-clause</varname></p>
         <codeblock>ON [ PRIMARY ] KEY <varname>rhs-expression</varname>.<varname>lhs-expression-key</varname> FOR <varname>lhs-expression</varname> </codeblock>
         <p><varname>rhs-expression</varname>: keyspace or expression corresponding to the right hand side of JOIN.</p>
         <p><varname>lhs-expression</varname>: keyspace or expression corresponding to the left hand side of JOIN.</p>
         <p><varname>lhs-expression-key</varname>: attribute in <varname>rhs-expression</varname>
                referencing primary key for <varname>lhs-expression</varname>.</p>
         <p><b>Example</b></p>
         <p>The following example counts the number of distinct "AA" airline routes for each
                airport:</p> 
                <codeblock>SELECT Count(DISTINCT route.sourceairport) AS distinctairports1 
FROM `travel-sample` airline 
  JOIN `travel-sample` route 
  ON KEY route.airlineid FOR airline 
WHERE  route.type = "route" 
  AND    airline.type = "airline" 
  AND    airline.iata = "AA"; </codeblock> 
                
     </section>
     
     <section id="unnest"><title>UNNEST Clause</title>
  <p>If a document or object contains a nested array, <codeph>UNNEST</codeph> conceptually performs
                a join of the nested array with its parent object. Each resulting joined object
                becomes an input to the query. Unnests can be chained.</p>
  <p><b>Syntax</b></p>
<codeblock>[ <varname>join-type</varname> ] UNNEST <varname>path</varname> [ [ AS ] <varname>alias</varname> ]</codeblock>
            <p>
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd>
                            <dl>
                                <dlentry>
                                    <dt>join-type</dt>
                                    <dd/>
                                </dlentry>
                            </dl>
                        </dd>
                    </dlentry>
                </dl>
            </p>
  <p>where join-type is <codeph>[ INNER | LEFT [ OUTER ] ]</codeph></p>
  <p>The first path element after each <codeph>UNNEST</codeph> must reference some preceding path. </p>
  <p>By default, an <codeph>INNER UNNEST</codeph> is performed. This means that for each result
                object produced, both the left-hand and right-hand source objects must be
                non-missing and non-null.</p>
  <p>If <codeph>LEFT</codeph> or <codeph>LEFT OUTER</codeph> is specified, then a left outer unnest
                is performed. At least one result object is produced for each left source object. If
                the right-hand source object is <codeph>NULL</codeph>, <codeph>MISSING</codeph>,
                empty, or a non-array value, then the result object's right-side value is
                    <codeph>MISSING</codeph> (omitted).</p>
  <p><b>Example</b></p>
  <p>If some customer documents contain an array of addresses under the address field, the following query retrieves 
   each nested address along with the parent customer's name.</p>
<codeblock>SELECT c.name, a.* FROM customer c UNNEST c.address a </codeblock>
  <p>Here is the result set:</p>
<codeblock> [
    { "name" : "Acme Inc.", "street" : "101 Main St.", 
        "zip" : "94040" },
    { "name" : "Acme Inc.", "street" : "300 Broadway", 
	"zip" : "10011" },
    { "name" : "Roadster Corp.", "street" : "3500 Wilshire Blvd.",
        "zip" : "90210" },
    { "name" : "Roadster Corp.", "street" : "4120 Alamo Dr.", 
	"zip" : "75019" }     
] </codeblock>
  <p>In the following example, The <codeph>UNNEST</codeph> clause iterates over the reviews array
                and collects the <codeph>reviewerName</codeph> and <codeph>publication</codeph> from
                each element in the array. This collection of objects can be used as input for other
                query operations.</p>
<codeblock>SELECT review.reviewerName, review.publication
   FROM beers AS b
      UNNEST review IN b.reviews   </codeblock>
  <p>Here is the result set:</p>
<codeblock>{"id": "7983345",
 "name": "Takayama Pale Ale",
 "brewer": "Hida Takayama Brewing Corp.",
 "reviews" : [ 
   {"reviewerName" : "Takeshi Kitano",
         "publication" : "Outdoor Japan Magazine","date": "3/2013"},
   {"reviewerName" : "Moto Ohtake", "publication" : "Japan Beer Times",
         "date" : "7/2013"} 
            ]
}         </codeblock>
     </section>
     <section id="nest"><title>NEST Clause</title><p>Nesting is conceptually the inverse of
                unnesting. Nesting performs a join across two keyspaces. But instead of producing a
                cross-product of the left and right inputs, a single result is produced for each
                left input, while the corresponding right inputs are collected into an array and
                nested as a single array-valued field in the result
                object.</p><b>Syntax</b><codeblock>[ <varname>join-type</varname> ] NEST <varname>from-path</varname> [ [ AS ] <varname>alias</varname> ] <varname>on-keys-clause</varname></codeblock><p>where
                join-type is <codeph>[ INNER | LEFT [ OUTER ] ]</codeph></p><p>
                <dl>
                    <dlentry>
                        <dt>Arguments</dt>
                        <dd/>
                    </dlentry>
                </dl>
            </p><p/><p>Nests can be chained with other <codeph>NEST</codeph>, <codeph>JOIN</codeph>,
                and <codeph>UNNEST</codeph> clauses. By default, an <codeph>INNER NEST</codeph> is
                performed. This means that for each result object produced, both the left and right
                source objects must be non-missing and non-null. The right-hand side result of
                    <codeph>NEST</codeph> is always an array or <codeph>MISSING</codeph>. If there
                is no matching right source object, then the right source object is as
                    follows:<table frame="all" rowsep="1" colsep="1" id="table_m3t_rmd_1bb">
                    <tgroup cols="2" align="left">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="1*"/>
                        <thead>
                            <row>
                                <entry>If the <codeph>ON KEYS</codeph> expression evaluates
                                    to</entry>
                                <entry>Then the right-side value is</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><codeph>MISSING</codeph></entry>
                                <entry><codeph>MISSING</codeph></entry>
                            </row>
                            <row>
                                <entry><codeph>NULL</codeph></entry>
                                <entry><codeph>MISSING</codeph></entry>
                            </row>
                            <row>
                                <entry>an array</entry>
                                <entry>an empty array</entry>
                            </row>
                            <row>
                                <entry>a non-array value</entry>
                                <entry>an empty array</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table></p><p>If <codeph>LEFT</codeph> or <codeph>LEFT OUTER</codeph> is specified,
                then a left outer nest is performed. One result object is produced for each left
                source object.</p><p><b>Example</b></p><p>This example shows the
                    <codeph>NEST</codeph> clause using <codeph>invoice</codeph> and
                    <codeph>invoice_item</codeph> objects.</p><p>Recall our invoice
                objects:</p><codeblock>{
     "customer_key": ...,
     "invoice_date": ...,
     "invoice_item_keys": [ ... ],
     "total": ...     
 }  </codeblock><p>And
                our <codeph>invoice_item</codeph> objects:
                </p><codeblock>{
         "invoice_key": ...,
         "product_key": ...,
         "unit_price": ...,
         "quantity": ...,
         "item_subtotal": ...     
}  </codeblock><p>If
                the FROM clause
                is:</p><codeblock>FROM invoice inv NEST invoice_item items ON KEYS inv.invoice_item_keys </codeblock><p>Then
                the results would
            be:</p><codeblock>  {
         "invoice" : {
             "customer_key": ...,
             "invoice_date": ...,
             "invoice_item_keys": [ ... ],
             "total": ...
         },
         "items" : [
             {
                 "invoice_key": ...,
                 "product_key": ...,
                 "unit_price": ...,
                 "quantity": ...,
                 "item_subtotal": ...
             },
             {
                 "invoice_key": ...,
                 "product_key": ...,
                 "unit_price": ...,
                 "quantity": ...,
                 "item_subtotal": ...
             }
         ]
     },
     {
         "invoice" : {
             "customer_key": ...,
             "invoice_date": ...,
             "invoice_item_keys": [ ... ],
             "total": ...
         },
         "items" : [
             {
                 "invoice_key": ...,
                 "product_key": ...,
                 "unit_price": ...,
                 "quantity": ...,
                 "item_subtotal": ...
             },
             {
                 "invoice_key": ...,
                 "product_key": ...,
                 "unit_price": ...,
                 "quantity": ...,
                 "item_subtotal": ...
             }
         ]
     },
     ... </codeblock></section>
     <section>
            <title>Arrays</title>
            <p>If an array occurs along a path, you can use array subscripts to select one element. </p>
            <p>In the following statement, the entire address array is selected for each customer. </p>
            <codeblock>SELECT a FROM customer.address a;    </codeblock>
            <codeblock>[
    {
        "a": [
                 { "street" : "101 Main St.", "zip" : "94040" },
                 { "street" : "300 Broadway", "zip" : "10011" }
             ]
    },
    {
        "a": [
                { "street" : "3500 Wilshire Blvd.", "zip" : "90210" },
                { "street" : "4120 Alamo Dr.", "zip" : "75019" }
             ]
    }
] </codeblock>
            <p>The following example uses array subscripts to select the first element of the
                address array for each customer. </p>
            <codeblock>SELECT * FROM customer.address[0]  </codeblock>
            <codeblock>[
     { "street" : "101 Main St.", "zip" : "94040" },
     { "street" : "3500 Wilshire Blvd.", "zip" : "90210" }
]  </codeblock>
        </section>
     <section id="as"><title>AS Keyword</title>
     
     <p>Like SQL, N1QL allows renaming fields using the <codeph>AS</codeph> keyword. However, N1QL
                also allows reshaping the data, which has no analog in SQL. To do this, you embed
                the attributes of the statement in the desired result object shape.</p>
     </section>
     <section><title>Aliases</title>
     <p>Aliases in the <codeph>FROM</codeph> clause create new names that can be referred to
                anywhere in the query. When an alias conflicts with a keyspace or field name in the
                same scope, the identifier always refers to the alias. This allows for consistent
                behavior in scenarios where an identifier only conflicts in some documents. For more
                information on aliases, see <xref href="identifiers.dita"/>.</p>
     </section>
 </conbody>
</concept>
